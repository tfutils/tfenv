#!/usr/bin/env bash

set -uo pipefail;

# Ensure we can execute standalone
if [ -n "${TFENV_ROOT:-""}" ]; then
  if [ "${TFENV_DEBUG:-0}" -gt 1 ]; then
    [ -n "${TFENV_HELPERS:-""}" ] \
      && log 'debug' "TFENV_ROOT already defined as ${TFENV_ROOT}" \
      || echo "[DEBUG] TFENV_ROOT already defined as ${TFENV_ROOT}" >&2;
  fi;
else
  export TFENV_ROOT="$(cd "$(dirname "${0}")/.." && pwd)";
  if [ "${TFENV_DEBUG:-0}" -gt 1 ]; then
    [ -n "${TFENV_HELPERS:-""}" ] \
      && log 'debug' "TFENV_ROOT declared as ${TFENV_ROOT}" \
      || echo "[DEBUG] TFENV_ROOT declared as ${TFENV_ROOT}" >&2;
  fi;
fi;

if [ -n "${TFENV_HELPERS:-""}" ]; then
  log 'debug' 'TFENV_HELPERS is set, not sourcing helpers again';
else
  [ "${TFENV_DEBUG:-0}" -gt 1 ] && echo "[DEBUG] Sourcing helpers from ${TFENV_ROOT}/lib/helpers.sh" >&2;
  if source "${TFENV_ROOT}/lib/helpers.sh"; then
    log 'debug' 'Helpers sourced successfully';
  else
    echo "[ERROR] Failed to source helpers from ${TFENV_ROOT}/lib/helpers.sh" >&2;
    exit 1;
  fi;
fi;

[ "${#}" -gt 1 ] && log 'error' 'usage: tfenv install [<version>]';

declare version_requested version regex;
declare arg="${1:-""}";

if [ -z "${arg}" ]; then
  version_file="$(tfenv-version-file)";
  if [ "${version_file}" != "${TFENV_ROOT}/version" ]; then
    version_requested="$(cat "${version_file}" || true)";
  fi;
else
  version_requested="${arg}";
fi;

if [[ "${version_requested}" =~ ^min-required$ ]]; then
  log 'info' 'Detecting minimal required version...';
  found_min_required="$(tfenv-min-required)";

  if [[ $? -eq 0 ]]; then
      log 'info' "Min required version is detected as ${found_min_required}";
      version_requested="${found_min_required}";
  else
    exit 1;
  fi;
fi;

if [[ "${version_requested}" =~ ^latest\:.*$ ]]; then
  version="${version_requested%%\:*}";
  regex="${version_requested##*\:}";
elif [[ "${version_requested}" =~ ^latest$ ]]; then
  version="${version_requested}";
  regex="^[0-9]\+\.[0-9]\+\.[0-9]\+$";
else
  version="${version_requested}";
  regex="^${version_requested}$";
fi;

[ -n "${version}" ] || log 'error' 'Version is not specified';
version="$(tfenv-list-remote | grep -e "${regex}" | head -n 1)";
[ -n "${version}" ] || log 'error' "No versions matching '${arg}' found in remote";

dst_path="${TFENV_ROOT}/versions/${version}";
if [ -f "${dst_path}/terraform" ]; then
  echo "Terraform v${version} is already installed";
  exit 0;
fi;

TFENV_ARCH="${TFENV_ARCH:-amd64}";
case "$(uname -s)" in
  Darwin*)
    os="darwin_${TFENV_ARCH}";
    ;;
  MINGW64*)
    os="windows_${TFENV_ARCH}";
    ;;
  MSYS_NT*)
    os="windows_${TFENV_ARCH}";
    ;;
  CYGWIN_NT*)
    os="windows_${TFENV_ARCH}";
    ;;
  *)
    os="linux_${TFENV_ARCH}";
    ;;
esac;

keybase_bin="$(command -v keybase 2>/dev/null)";
shasum_bin="$(command -v shasum 2>/dev/null)";

TFENV_REMOTE="${TFENV_REMOTE:-https://releases.hashicorp.com}";
version_url="${TFENV_REMOTE}/terraform/${version}";

# Thanks for the inconsistency in 0.12-alpha, Hashicorp(!)
if [[ "${version}" =~ 0.12.0-alpha[3-9] ]]; then
  tarball_name="terraform_${version}_terraform_${version}_${os}.zip";
else
  tarball_name="terraform_${version}_${os}.zip";
fi;

shasums_name="terraform_${version}_SHA256SUMS";

log 'info' "Installing Terraform v${version}";

# Create a local temporary directory for downloads
download_tmp="$(mktemp -d tfenv_download.XXXXXX)" || log 'error' "Unable to create temporary download directory in $(pwd)";
# Clean it up in case of error
trap "rm -rf ${download_tmp}" EXIT;

declare curl_progress="";
case "${TFENV_CURL_OUTPUT:-2}" in
  '2')
    log 'debug' 'Setting curl progress bar with "-#"';
    curl_progress="-#";
    ;;
  '1')
    log 'debug' 'Using default curl output';
    curl_progress="";
    ;;
  '0')
    log 'debug' 'Running curl silently with "-s"';
    curl_progress="-s";
    ;;
  *)
    log 'error' 'TFENV_CURL_OUTPUT specified, but not with a support value ([0,1,2])';
    ;;
esac;

log 'info' "Downloading release tarball from ${version_url}/${tarball_name}";
curlw ${curl_progress} -f -o "${download_tmp}/${tarball_name}" "${version_url}/${tarball_name}" || log 'error' 'Tarball download failed';
log 'info' "Downloading SHA hash file from ${version_url}/${shasums_name}";
curlw -s -f -o "${download_tmp}/${shasums_name}" "${version_url}/${shasums_name}" || log 'error' 'SHA256 hashes download failed';

download_signature() {
  log 'info' "Downloading SHA hash signature file from ${version_url}/${shasums_name}.sig";
  curlw -s -f \
    -o "${download_tmp}/${shasums_name}.sig" \
    "${version_url}/${shasums_name}.sig" \
    && log 'debug' "SHA256SUMS signature file downloaded successfully to ${download_tmp}/${shasums_name}.sig" \
    || log 'error' 'SHA256SUMS signature download failed';
};

# Verify signature if verification mechanism (keybase, gpg, etc) is present
if [[ -n "${keybase_bin}" && -x "${keybase_bin}" ]]; then
  "${keybase_bin}" status | grep -Eq '^Logged in:[[:space:]]*yes';
  keybase_logged_in="${?}";
  "${keybase_bin}" list-following | grep -Fq hashicorp;
  keybase_following_hc="${?}";

  if [[ "${keybase_logged_in}" -ne 0 || "${keybase_following_hc}" -ne 0 ]]; then
    log 'warn' 'Unable to verify OpenPGP signature unless logged into keybase and following hashicorp';
  else
    download_signature;
    "${keybase_bin}" pgp verify \
      -S hashicorp \
      -d "${download_tmp}/${shasums_name}.sig" \
      -i "${download_tmp}/${shasums_name}" \
      && log 'debug' 'SHA256SUMS signature matched' \
      || log 'error' 'SHA256SUMS signature does not match!';
  fi;

elif [[ -f "${TFENV_ROOT}/use-gnupg" ]]; then
  # GnuPG uses the user's keyring, and any web-of-trust or local signatures or
  # anything else they have setup.  This is the crazy-powerful mode which is
  # overly confusing to newcomers.  We don't support it without the user creating
  # the file use-gnupg, optionally with directives in it.
  gnupg_command="$(sed -E -n -e 's/^binary: *//p' <"${TFENV_ROOT}/use-gnupg")";
  [[ -n "${gnupg_command}" ]] || gnupg_command=gpg;

  download_signature;
  # Deliberately unquoted command, in case caller has something fancier in "use-gnupg".
  # Also, don't use batch mode.  If someone specifies GnuPG, let them deal with any prompting.
  ${gnupg_command} \
    --verify "${download_tmp}/${shasums_name}.sig" \
    "${download_tmp}/${shasums_name}" \
    || log 'error' 'PGP signature rejected by GnuPG';

elif [[ -f "${TFENV_ROOT}/use-gpgv" ]]; then
  # gpgv is a much simpler interface to verification, but does require that the
  # key have been downloaded and marked trusted.
  # We don't force the caller to trust the tfenv repo's copy of their key, they
  # have to choose to make that trust decision.
  gpgv_command="$(sed -E -n -e 's/^binary: *//p' <"${TFENV_ROOT}/use-gpgv")";
  trust_tfenv="$(sed -E -n -e 's/^trust.?tfenv: *//p' <"${TFENV_ROOT}/use-gpgv")";
  [[ -n "${gpgv_command}" ]] || gpgv_command=gpgv;

  download_signature;
  if [[ "${trust_tfenv}" == 'yes' ]]; then
    ${gpgv_command} \
      --keyring "${TFENV_ROOT}/share/hashicorp-keys.pgp" \
      "${download_tmp}/${shasums_name}.sig" \
      "${download_tmp}/${shasums_name}" \
      || log 'error' 'PGP signature rejected';
  else
    ${gpgv_command} \
      "${download_tmp}/${shasums_name}.sig" \
      "${download_tmp}/${shasums_name}" \
      || log 'error' 'PGP signature rejected';
  fi;
else
  # Warning about this avoids an unwarranted sense of confidence in the SHA check
  log 'warn' 'No keybase install found, skipping OpenPGP signature verification';
fi;

if [[ -n "${shasum_bin}" && -x "${shasum_bin}" ]]; then
  (
    cd "${download_tmp}";
    "${shasum_bin}" \
      -a 256 \
      -s \
      -c <(grep -F "${tarball_name}" "${shasums_name}") \
      || log 'error' 'SHA256 hash does not match!';
  );
else
  # Lack of shasum deserves a proper warning
  log 'warn' 'No shasum tool available. Skipping SHA256 hash validation';
fi;

mkdir -p "${dst_path}" || log 'error' "Failed to make directory ${dst_path}";

declare unzip_output="$(unzip "${download_tmp}/${tarball_name}" -d "${dst_path}" || log 'error' 'Tarball unzip failed')";
while IFS= read -r unzip_line; do
 log 'info' "${unzip_line}";
done < <(printf '%s\n' "${unzip_output}");

log 'info' "Installation of terraform v${version} successful";
tfenv-use "${version}";
